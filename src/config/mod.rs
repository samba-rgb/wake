use serde::{Deserialize, Serialize};
use std::path::{Path, PathBuf};
use std::fs;
use anyhow::{Result, Context, anyhow};
use directories::ProjectDirs;

#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct Config {
    pub autosave: AutosaveConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AutosaveConfig {
    pub enabled: bool,
    pub path: Option<String>,
}

impl Default for AutosaveConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            path: None,
        }
    }
}

impl Config {
    /// Get the configuration file path
    pub fn config_file_path() -> Result<PathBuf> {
        let proj_dirs = ProjectDirs::from("com", "wake", "wake")
            .context("Unable to determine project directories")?;
        
        let config_dir = proj_dirs.config_dir();
        fs::create_dir_all(config_dir)
            .context("Failed to create config directory")?;
        
        Ok(config_dir.join("config.toml"))
    }
    
    /// Load configuration from file
    pub fn load() -> Result<Self> {
        let config_path = Self::config_file_path()?;
        
        if !config_path.exists() {
            return Ok(Self::default());
        }
        
        let content = fs::read_to_string(&config_path)
            .context("Failed to read config file")?;
        
        let config: Config = toml::from_str(&content)
            .context("Failed to parse config file")?;
        
        Ok(config)
    }
    
    /// Save configuration to file
    pub fn save(&self) -> Result<()> {
        let config_path = Self::config_file_path()?;
        
        let content = toml::to_string_pretty(self)
            .context("Failed to serialize config")?;
        
        fs::write(&config_path, content)
            .context("Failed to write config file")?;
        
        println!("Configuration saved to: {}", config_path.display());
        Ok(())
    }
    
    /// Set autosave configuration
    pub fn set_autosave(&mut self, enabled: bool, path: Option<String>) {
        self.autosave.enabled = enabled;
        self.autosave.path = path;
    }
    
    /// Get autosave file path (either configured path or generate timestamp-based path)
    pub fn get_autosave_path(&self, write_file: Option<&str>) -> Option<String> {
        if !self.autosave.enabled {
            return None;
        }
        
        // Priority: -w flag > configured path > auto-generated path
        if let Some(write_path) = write_file {
            Some(write_path.to_string())
        } else if let Some(ref configured_path) = self.autosave.path {
            Some(configured_path.clone())
        } else {
            // Generate timestamp-based filename
            let timestamp = chrono::Utc::now().format("%Y%m%d_%H%M%S");
            Some(format!("wake_{}.log", timestamp))
        }
    }
    
    /// Display current configuration
    pub fn display(&self) -> String {
        let mut output = String::new();
        output.push_str("Wake Configuration:\n");
        output.push_str("==================\n\n");
        
        // Autosave configuration
        output.push_str(&format!("Autosave:\n"));
        output.push_str(&format!("  enabled: {}\n", self.autosave.enabled));
        if let Some(ref path) = self.autosave.path {
            output.push_str(&format!("  path: {}\n", path));
        } else {
            output.push_str(&format!("  path: <auto-generated>\n"));
        }
        
        // Configuration file location
        if let Ok(config_path) = Self::config_file_path() {
            output.push_str(&format!("\nConfig file: {}\n", config_path.display()));
        }
        
        output
    }
    
    /// Display specific configuration key
    pub fn display_key(&self, key: &str) -> Result<String> {
        match key.to_lowercase().as_str() {
            "autosave" => {
                let mut output = String::new();
                output.push_str(&format!("autosave.enabled = {}\n", self.autosave.enabled));
                if let Some(ref path) = self.autosave.path {
                    output.push_str(&format!("autosave.path = {}\n", path));
                } else {
                    output.push_str(&format!("autosave.path = <auto-generated>\n"));
                }
                Ok(output)
            }
            "autosave.enabled" => Ok(format!("{}\n", self.autosave.enabled)),
            "autosave.path" => {
                if let Some(ref path) = self.autosave.path {
                    Ok(format!("{}\n", path))
                } else {
                    Ok("<auto-generated>\n".to_string())
                }
            }
            _ => Err(anyhow!("Unknown configuration key: {}. Available keys: autosave, autosave.enabled, autosave.path", key))
        }
    }
    
    /// List all available configuration keys
    pub fn list_keys() -> Vec<&'static str> {
        vec![
            "autosave",
            "autosave.enabled", 
            "autosave.path"
        ]
    }
}